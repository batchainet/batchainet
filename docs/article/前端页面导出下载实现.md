## 安装

```Shell
pnpm install html2canvas jspdf
```
## 封装函数

通过html内容生成PDF文件

```JavaScript
import html2Canvas from 'html2canvas'
import JsPDF from 'jspdf'

// 长截图，不分页
export const noPagingDownPDF = (el, title = 'title', scale = 3) => {
    let cloneDom = el.cloneNode(true)
    cloneDom.style.position = 'absolute'
    cloneDom.style.top = '-10000px'
    cloneDom.style.zIndex = '-100'
    document.body.appendChild(cloneDom)

    cloneDom.style.height = cloneDom.scrollHeight + 'px'
    console.log(cloneDom.scrollHeight)

    const canvas = document.createElement('canvas') // 生成canvas上下文
    const context = canvas.getContext('2d')
    let _w = cloneDom.clientWidth // 获取需要导出pdf区域的宽度和高度
    let _h = cloneDom.clientHeight
    if (_w > _h) {
        _h = _w
    }
    canvas.width = _w * scale
    canvas.height = _h * scale
    context.scale(scale, scale)
    let opts = {
        scale: 1,
        width: _w, // dom 原始宽度
        height: _h,
        canvas,
        useCORS: true  // 允许canvas画布内可以跨域请求外部链接图片, 允许跨域请求。
    }
    // 以上部分为强化清晰度，放大canvas画布
    html2Canvas(cloneDom, opts).then(canvas => {
        // 自定义宽高
        let contentWidth = canvas.width / scale
        let contentHeight = canvas.height / scale
        let pdf = new JsPDF('', 'pt', [contentWidth, contentHeight])  // 自定义宽高
        let pageData = canvas.toDataURL('image/jpeg', 1.0) // 转换图片为dataURL
        pdf.addImage(pageData, 'JPEG', 0, 0, contentWidth, contentHeight) // 添加图像到页面
        pdf.save(`${title}.pdf`)
        cloneDom.remove() // 进行及时清理
        cloneDom = null
    })
}

/*
* 使用说明
* ele:需要导出pdf的容器元素(dom节点 不是id)
* pdfFileName: 导出文件的名字
* options配置项：
*   width A4纸宽度
*   height A4纸高度
*   scale 缩放层级，提高清晰度
*   backgroundColor 纸张背景颜色
*   margin 纸张左右边距
*   splitClassName: 避免分段截断的类名 当pdf有多页时需要传入此参数 , 避免pdf分页时截断元素  如表格<tr class="itemClass"></tr>
* */

// 按照A4纸分页
export const PagingDownPDF = (ele, pdfFileName = null, options = {}) => {
    const { width = 595, height = 842, scale = 3, backgroundColor = '#f3f3f3', margin = 0, splitClassName } = options
    const A4_WIDTH = width
    const A4_HEIGHT = height

    const getPDF = async resolve => {
        const eleW = ele.offsetWidth// 获得该容器的宽
        const eleH = ele.scrollHeight// 获得该容器的高
        const eleOffsetTop = ele.offsetTop// 获得该容器到文档顶部的距离
        const eleOffsetLeft = ele.offsetLeft// 获得该容器到文档最左的距离
        const canvas = document.createElement('canvas')
        let abs = 0
        const win_in = document.documentElement.clientWidth || document.body.clientWidth// 获得当前可视窗口的宽度（不包含滚动条）
        const win_out = window.innerWidth// 获得当前窗口的宽度（包含滚动条）
        if (win_out > win_in) {
            abs = (win_out - win_in) / 2// 获得滚动条宽度的一半
        }
        canvas.width = eleW * scale// 将画布宽&&高放大两倍
        canvas.height = eleH * scale
        const context = canvas.getContext('2d')
        context.scale(scale, scale) // 增强图片清晰度
        context.translate(-eleOffsetLeft - abs, -eleOffsetTop)
        html2Canvas(ele, {
            scale: 1,
            width: eleW, // dom 原始宽度
            height: eleH,
            backgroundColor,
            canvas,
            useCORS: true// 允许canvas画布内可以跨域请求外部链接图片, 允许跨域请求。
        }).then(async canvas => {
            const contentWidth = canvas.width
            const contentHeight = canvas.height
            // 一页pdf显示html页面生成的canvas高度;
            const pageHeight = (contentWidth / A4_WIDTH) * A4_HEIGHT // 这样写的目的在于保持宽高比例一致 pageHeight/canvas.width = a4纸高度/a4纸宽度// 宽度和canvas.width保持一致
            // 未生成pdf的html页面高度
            let leftHeight = contentHeight
            // 页面偏移
            let position = 0
            // a4纸的尺寸[595,842],单位像素，html页面生成的canvas在pdf中图片的宽高
            const imgWidth = A4_WIDTH - margin // 有margin的话页面就有右边距
            const imgHeight = (A4_WIDTH / contentWidth) * contentHeight
            const pageData = canvas.toDataURL('image/jpeg', 1.0)
            const pdf = JsPDF('', 'pt', 'a4')
            // 有两个高度需要区分，一个是html页面的实际高度，和生成pdf的页面高度(841.89)
            // 当内容未超过pdf一页显示的范围，无需分页
            if (leftHeight < pageHeight) {
                // 在pdf.addImage(pageData, 'JPEG', 左，上，宽度，高度)设置在pdf中显示；
                pdf.addImage(pageData, 'JPEG', margin / 2, 0, imgWidth, imgHeight)
            } else {
                // 分页
                while (leftHeight > 0) {
                    pdf.addImage(pageData, 'JPEG', margin / 2, position, imgWidth, imgHeight)
                    leftHeight -= pageHeight
                    position -= A4_HEIGHT
                    // 避免添加空白页
                    if (leftHeight > 0) {
                        pdf.addPage()
                    }
                }
            }
            pdf.save(pdfFileName + '.pdf', { returnPromise: true }).then(() => {
                // 去除添加的空div 防止页面混乱
                const doms = document.querySelectorAll('.emptyDiv')
                for (let i = 0; i < doms.length; i++) {
                    doms[i].remove()
                }
            })
            ele.style.height = ''
            resolve()
        })
    }

    return new Promise((resolve, reject) => {
        ele.style.height = 'initial'
        const target = ele
        const pageHeight = target.scrollWidth / A4_WIDTH * A4_HEIGHT
        // 获取分割dom，此处为class类名为item的dom
        const domList = document.getElementsByClassName(splitClassName)
        // 进行分割操作，当dom内容已超出a4的高度，则将该dom前插入一个空dom，把他挤下去，分割
        let pageNum = 1 // pdf页数
        const eleBounding = ele.getBoundingClientRect()
        for (let i = 0; i < domList.length; i++) {
            const node = domList[i]
            const bound = node.getBoundingClientRect()
            const offset2Ele = bound.top - eleBounding.top
            const currentPage = Math.ceil((bound.bottom - eleBounding.top) / pageHeight) // 当前元素应该在哪一页
            if (pageNum < currentPage) {
                pageNum++
                const divParent = domList[i].parentNode // 获取该div的父节点
                const newNode = document.createElement('div')
                newNode.className = 'emptyDiv'
                newNode.style.background = backgroundColor
                newNode.style.height = (pageHeight * (pageNum - 1) - offset2Ele + 30) + 'px' // +30为了在换下一页时有顶部的边距
                newNode.style.width = '100%'
                divParent.insertBefore(newNode, node) // 在每一个节点前面插入一个空的新节点，防止内容被分割截断
            }
        }
        // 异步函数，导出成功后处理交互
        getPDF(resolve, reject)
    })
}
```

这个正常点

```JavaScript
// 按照A4纸分页
export const PagingDownPDF = (ele, pdfFileName = null, options = {}) => {
    const { width = 595, height = 842, scale = 3, backgroundColor = '#f3f3f3', margin = 0, splitClassName } = options
    const A4_WIDTH = width
    const A4_HEIGHT = height

    const getPDF = async resolve => {
        const eleW = ele.offsetWidth// 获得该容器的宽
        const eleH = ele.scrollHeight// 获得该容器的高
        const canvas = document.createElement('canvas')
        let abs = 0
        const win_in = document.documentElement.clientWidth || document.body.clientWidth// 获得当前可视窗口的宽度（不包含滚动条）
        const win_out = window.innerWidth// 获得当前窗口的宽度（包含滚动条）
        if (win_out > win_in) {
            abs = (win_out - win_in) / 2// 获得滚动条宽度的一半
        }
        canvas.width = eleW * scale// 将画布宽&&高放大两倍
        canvas.height = eleH * scale
        const context = canvas.getContext('2d')
        context.scale(scale, scale) // 增强图片清晰度
        html2Canvas(ele, {
            scale: 1,
            width: eleW, // dom 原始宽度
            height: eleH,
            backgroundColor,
            canvas,
            useCORS: true// 允许canvas画布内可以跨域请求外部链接图片, 允许跨域请求。
        }).then(async canvas => {
            const contentWidth = canvas.width
            const contentHeight = canvas.height
            // 一页pdf显示html页面生成的canvas高度;
            const pageHeight = (contentWidth / A4_WIDTH) * A4_HEIGHT // 这样写的目的在于保持宽高比例一致 pageHeight/canvas.width = a4纸高度/a4纸宽度// 宽度和canvas.width保持一致
            // 未生成pdf的html页面高度
            let leftHeight = contentHeight
            // 页面偏移
            let position = 0
            // a4纸的尺寸[595,842],单位像素，html页面生成的canvas在pdf中图片的宽高
            const imgWidth = A4_WIDTH - margin // 有margin的话页面就有右边距
            const imgHeight = (A4_WIDTH / contentWidth) * contentHeight
            const pageData = canvas.toDataURL('image/jpeg', 1.0)
            const pdf = JsPDF('', 'pt', 'a4')
            // 有两个高度需要区分，一个是html页面的实际高度，和生成pdf的页面高度(841.89)
            // 当内容未超过pdf一页显示的范围，无需分页
            if (leftHeight < pageHeight) {
                // 在pdf.addImage(pageData, 'JPEG', 左，上，宽度，高度)设置在pdf中显示；
                pdf.addImage(pageData, 'JPEG', margin / 2, 0, imgWidth, imgHeight)
            } else {
                // 分页
                while (leftHeight > 0) {
                    pdf.addImage(pageData, 'JPEG', margin / 2, position, imgWidth, imgHeight)
                    leftHeight -= pageHeight
                    position -= A4_HEIGHT
                    // 避免添加空白页
                    if (leftHeight > 0) {
                        pdf.addPage()
                    }
                }
            }
            pdf.save(pdfFileName + '.pdf', { returnPromise: true }).then(() => {
                // 去除添加的空div 防止页面混乱
                const doms = document.querySelectorAll('.emptyDiv')
                for (let i = 0; i < doms.length; i++) {
                    doms[i].remove()
                }
            })
            ele.style.height = ''
            resolve()
        })
    }

    return new Promise((resolve, reject) => {
        ele.style.height = 'initial'
        const target = ele
        const pageHeight = target.scrollWidth / A4_WIDTH * A4_HEIGHT
        // 获取分割dom，此处为class类名为item的dom
        const domList = document.getElementsByClassName(splitClassName)
        // 进行分割操作，当dom内容已超出a4的高度，则将该dom前插入一个空dom，把他挤下去，分割
        let pageNum = 1 // pdf页数
        const eleBounding = ele.getBoundingClientRect()
        for (let i = 0; i < domList.length; i++) {
            const node = domList[i]
            const bound = node.getBoundingClientRect()
            const offset2Ele = bound.top - eleBounding.top
            const currentPage = Math.ceil((bound.bottom - eleBounding.top) / pageHeight) // 当前元素应该在哪一页
            if (pageNum < currentPage) {
                pageNum++
                const divParent = domList[i].parentNode // 获取该div的父节点
                const newNode = document.createElement('div')
                newNode.className = 'emptyDiv'
                newNode.style.background = backgroundColor
                newNode.style.height = (pageHeight * (pageNum - 1) - offset2Ele + 30) + 'px' // +30为了在换下一页时有顶部的边距
                newNode.style.width = '100%'
                divParent.insertBefore(newNode, node) // 在每一个节点前面插入一个空的新节点，防止内容被分割截断
            }
        }
        // 异步函数，导出成功后处理交互
        getPDF(resolve, reject)
    })
}
```


